////////////////////////////////////////////////////////////////////////////////
//     Copyright (c) Jon DuBois 2022. This file is part of pseudoluminal.     //
//                                                                            //
// This program is free software: you can redistribute it and/or modify       //
// it under the terms of the GNU Affero General Public License as published   //
// by the Free Software Foundation, either version 3 of the License, or       //
// (at your option) any later version.                                        //
//                                                                            //
// This program is distributed in the hope that it will be useful,            //
// but WITHOUT ANY WARRANTY; without even the implied warranty of             //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              //
// GNU Affero General Public License for more details.                        //
//                                                                            //
// You should have received a copy of the GNU Affero General Public License   //
// along with this program.  If not, see <https://www.gnu.org/licenses/>.     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
// Compute shader.                                                            //
////////////////////////////////////////////////////////////////////////////////

#version 450 core

#include "funcs.glib"
#pragma use_vulkan_memory_model

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_NV_cooperative_matrix : enable
#extension GL_NV_integer_cooperative_matrix : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_control_flow_attributes : enable

layout( local_size_x = 4, local_size_y = 4 ) in;

layout( binding = 1) buffer outcolors{
  float outbuf[ 256 ];
};
layout( binding = 2) buffer incolors{
  float inbuf[ 256 ];
};
layout( binding = 3) buffer b{
  float bmat[ 256 ];
};
layout( binding = 4) buffer c{
  float cmat[ 256 ];
};

const uint sz = 256;  
fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> tcmat[ sz ]; 
void main(){
  // barrier();
  // fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> b[ sz ]; 
  // fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> c[ sz ]; 
  // fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> d[ sz ]; 
  
  // for( uint i = 0; i < sz; ++i ){
  //   const uint el = i * 1;
  //   const uint st = 16;
  //   coopMatLoadNV( tcmat[ i ], outbuf, el, st, false );
  // }
  // barrier();
  // for( uint i = 0; i < sz; ++i ){
  //   const uint el = i * 1;
  //   const uint st = 16;
  //   coopMatLoadNV( b[ i ], bmat, el, st, false );
  // }
  // barrier();
  // for( uint i = 0; i < sz; ++i ){
  //   const uint el = i * 1;
  //   const uint st = 16;
  //   coopMatLoadNV( c[ i ], cmat, el, st, false );
  // }
  // barrier();
  // for( uint i = 0; i < sz; ++i ){
  //   d[ i ] = coopMatMulAddNV( tcmat[ i ], b[ i ], c[ i ] );
  // }
  // barrier();
  // for( uint i = 0; i < sz; ++i ){
  //   const uint el = i * 1;
  //   const uint st = 16;
  //   coopMatStoreNV( d[ i ], outbuf, el, st, false );
  // }
  // barrier();
  // outbuf[ 0 ] = tcmat[ 0 ].length();
  // outbuf[ 1 ] = gl_NumWorkGroups.x;
  // outbuf[ 2 ] = gl_NumWorkGroups.y;
  // outbuf[ 3 ] = gl_NumWorkGroups.z;
  // outbuf[ 4 ] = gl_SubgroupSize;
  // barrier();

  mat4 tm1 = faceMat( vec3( 1, 3, 5 ) );
  vec4 tv1 = tm1 * vec4( 1, 1, 1, 1  );
  
  outbuf[ gl_LocalInvocationID.y * 16 + gl_LocalInvocationID.x ] =
    tm1[ gl_LocalInvocationID.y ][ gl_LocalInvocationID.x ];
  outbuf[ ( 6 ) * 16 + gl_LocalInvocationID.x ] =
    tv1[ gl_LocalInvocationID.x ];
  
  // for( uint i = 0; i < tcmat.length(); i++ )
  //   outbuf[ i ]
  // 	= tcmat[ i ];
  //  barrier();
     
  
  // if( gl_GlobalInvocationID.x == 255 ){
  // }
  // barrier();
}
 
