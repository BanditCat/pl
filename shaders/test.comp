////////////////////////////////////////////////////////////////////////////////
//     Copyright (c) Jon DuBois 2022. This file is part of pseudoluminal.     //
//                                                                            //
// This program is free software: you can redistribute it and/or modify       //
// it under the terms of the GNU Affero General Public License as published   //
// by the Free Software Foundation, either version 3 of the License, or       //
// (at your option) any later version.                                        //
//                                                                            //
// This program is distributed in the hope that it will be useful,            //
// but WITHOUT ANY WARRANTY; without even the implied warranty of             //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              //
// GNU Affero General Public License for more details.                        //
//                                                                            //
// You should have received a copy of the GNU Affero General Public License   //
// along with this program.  If not, see <https://www.gnu.org/licenses/>.     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
// Compute shader.                                                            //
////////////////////////////////////////////////////////////////////////////////

#version 450 core
#pragma use_vulkan_memory_model

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_NV_cooperative_matrix : enable
#extension GL_NV_integer_cooperative_matrix : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_control_flow_attributes : enable

layout( binding = 1) coherent buffer outcolors{
  float outbuf[ 256 ];
};
layout( binding = 2) coherent buffer incolors{
  float inbuf[ 256 ];
};
layout( binding = 3) coherent buffer b{
  float bmat[ 256 ];
};
layout( binding = 4) coherent buffer c{
  float cmat[ 256 ];
};

const uint sz = 256;  
fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> tcmat[ sz ]; 
void main(){
  barrier();
  fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> b[ sz ]; 
  fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> c[ sz ]; 
  fcoopmatNV<16, gl_ScopeSubgroup  , 16, 16> d[ sz ]; 
  
  for( uint i = 0; i < sz; ++i ){
    const uint el = i * 1;
    const uint st = 16;
    coopMatLoadNV( tcmat[ i ], outbuf, el, st, false );
  }
  barrier();
  for( uint i = 0; i < sz; ++i ){
    const uint el = i * 1;
    const uint st = 16;
    coopMatLoadNV( b[ i ], bmat, el, st, false );
  }
  barrier();
  for( uint i = 0; i < sz; ++i ){
    const uint el = i * 1;
    const uint st = 16;
    coopMatLoadNV( c[ i ], cmat, el, st, false );
  }
  barrier();
  for( uint i = 0; i < sz; ++i ){
    d[ i ] = coopMatMulAddNV( tcmat[ i ], b[ i ], c[ i ] );
  }
  barrier();
  for( uint i = 0; i < sz; ++i ){
    const uint el = i * 1;
    const uint st = 16;
    coopMatStoreNV( d[ i ], outbuf, el, st, false );
  }
  barrier();
  outbuf[ 255 ] = tcmat[ 0 ].length();
  barrier();
  // for( uint i = 0; i < tcmat.length(); i++ )
  //   outbuf[ i ]
  // 	= tcmat[ i ];
  //  barrier();
     
  
  // if( gl_GlobalInvocationID.x == 255 ){
  // }
  // barrier();
}
 
