////////////////////////////////////////////////////////////////////////////////
//     Copyright (c) Jon DuBois 2022. This file is part of pseudoluminal.     //
//                                                                            //
// This program is free software: you can redistribute it and/or modify       //
// it under the terms of the GNU Affero General Public License as published   //
// by the Free Software Foundation, either version 3 of the License, or       //
// (at your option) any later version.                                        //
//                                                                            //
// This program is distributed in the hope that it will be useful,            //
// but WITHOUT ANY WARRANTY; without even the implied warranty of             //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              //
// GNU Affero General Public License for more details.                        //
//                                                                            //
// You should have received a copy of the GNU Affero General Public License   //
// along with this program.  If not, see <https://www.gnu.org/licenses/>.     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
// Compute shader.                                                            //
////////////////////////////////////////////////////////////////////////////////

#version 460

#extension GL_EXT_control_flow_attributes : enable

layout( local_size_x =  192  ) in;

struct particle{
  vec4 pos;
  vec4 vel;
};
layout( binding = 1) writeonly  buffer oparticleBuffer{
  particle ops[];
};
layout( binding = 2) readonly  buffer iparticleBuffer{
  particle ips[];
};

shared particle shr[ gl_WorkGroupSize.x ];

void main(){
  const uint size = gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  vec3 vel = vec3( 0 );
  uint j = gl_GlobalInvocationID.x;
  // [[unroll]]for( uint i = 0; i <; ++i )
  //   shr[ i ] = ips[ i ];
  // barrier();
  [[unroll]]for( uint i = 0; i < size; ++i )
    if( i != j ){
      vec3 dif = ips[ i ].pos.xyz - ips[ j ].pos.xyz;
      float dist = sqrt( dot( dif, dif ) ) * 128;
      vec3 fvec = ( dif / dist ) / ( dist * dist );
      vel += fvec;
    }
  vec3 mvel = ips[ j ].vel.xyz + vel * 0.0005;
  mvel = clamp( mvel, -0.01, 0.01 );
  ops[ j ].vel.xyz = mvel;
  ops[ j ].pos.xyz = ips[ j ].pos.xyz + mvel;
  // [[unroll]]for( uint i = 0; i <  gl_WorkGroupSize.; ++i )
  //   ops[ i ] = shr[ i ];
}
 
